import sys  # Like #include <stdlib.h> - gives us argv
from config_parser import parse_config  # Import function from another file

# Main entry point
def main():
    print("Amazeing is being initialized...")
    
    # Check command line arguments (like argc in C)
    # sys.argv[0] = program name, sys.argv[1] = first argument
    if len(sys.argv) != 2:  # We want exactly 2 items: program name + config file
        print("Usage: python3 a_maze_ing.py config.txt")
        sys.exit(1)  # Like return 1; or exit(1) in C
    
    print(f"Loading config file: {sys.argv[1]}")  # f-string = formatted string (like printf)
    
    # Try-catch block (like error handling in C but cleaner)
    try:
        config = parse_config(sys.argv[1])  # Call function, returns a dict
    except ValueError as e:  # Catch specific error type
        print(f"Error: {e}")
        return
    
    print("Config loaded successfully!")
    print(config)  # Print the whole dict (struct)
    
    # TODO: You'll add maze generation logic here later
    # config will be a dict like: {'WIDTH': 20, 'HEIGHT': 15, ...}

# This is like checking "am I the main program being run?"
# (vs being imported as a module by another file)
if __name__ == "__main__":
    main()
```

---

## **config.txt** (Example configuration file)
```
# This is a comment (like // in C)
WIDTH=20           # Maze width in cells
HEIGHT=15          # Maze height in cells
ENTRY=0,0          # Starting position (x,y)
EXIT=19,14         # Exit position (x,y)
OUTPUT_FILE=maze.txt  # Where to save the maze
PERFECT=True       # Should maze be "perfect" (single solution path)




import sys
from typing import Dict, Tuple  # Type hints (optional, for documentation)
from pathlib import Path  # For file path handling (not used yet)

def parse_config(filename: str) -> dict:
    """
    Parse maze config file.
    
    In C terms: This is like reading a file line by line,
    splitting by '=', and storing in a struct.
    
    Returns dict with keys: WIDTH, HEIGHT, ENTRY, EXIT, OUTPUT_FILE, PERFECT
    Raises ValueError if invalid format or missing required keys
    """
    
    # Create empty dict (like initializing a struct to zeros)
    config = {}
    
    # Set of required keys (like an array of strings)
    require_keys = {'WIDTH', 'HEIGHT', 'ENTRY', 'EXIT', 'OUTPUT_FILE', 'PERFECT'}
    
    # Open file (automatically closes when done - no need for fclose!)
    with open(filename, 'r') as file:
        
        # Loop through each line (like while(fgets(...)))
        for line in file:
            line = line.strip()  # Remove whitespace/newlines (like trim in C)
            
            # Skip empty lines
            if not line:
                continue
            
            # Skip comments (lines starting with #)
            if line.startswith('#'):
                continue
            
            # Split line by '=' (like strtok in C)
            parts = line.split('=')
            
            # Should be exactly 2 parts: KEY and VALUE
            if len(parts) != 2:
                # Throw error (like returning an error code, but Python uses exceptions)
                raise ValueError(f"Invalid line format: '{line}'. Expected KEY=VALUE")
            
            # Extract key and value, remove whitespace
            key = parts[0].strip()
            value = parts[1].strip()
            
            # Store in dict (like config.WIDTH = value)
            config[key] = value
    
    # TODO: You still need to add:
    # 1. Check that all required keys are present
    # 2. Convert strings to proper types:
    #    - WIDTH, HEIGHT -> int
    #    - ENTRY, EXIT -> tuple of (x, y)
    #    - PERFECT -> bool
    #    - OUTPUT_FILE stays as string
    
    return config  # Return the dict (like returning a struct)


    # This validates the output maze file format
# It checks that neighboring cells have matching wall encodings

import sys

# Check command line arguments
if len(sys.argv) != 2:
    print(f"Usage: python3 {sys.argv[0]} <output_file>")
    sys.exit(1)

# Create empty 2D list (like a 2D array: int grid[][];)
g = []

# Read file and parse hex digits
for line in open(sys.argv[1]):
    if line.strip() == '':  # Stop at empty line
        break
    
    # Convert each character to hex integer
    # Example: 'F' -> 15, 'A' -> 10
    # List comprehension: [expression for item in list]
    # In C: for(i=0; i<len; i++) { array[i] = hex_to_int(line[i]); }
    g.append([int(c, 16) for c in line.strip(' \t\n\r')])

# Validate wall encoding
# Each cell is a 4-bit number representing walls:
# Bit 0 (1): North wall
# Bit 1 (2): East wall
# Bit 2 (4): South wall
# Bit 3 (8): West wall

for r in range(len(g)):  # For each row (like for(r=0; r<rows; r++))
    for c in range(len(g[0])):  # For each column
        v = g[r][c]  # Current cell value
        
        # Check that walls match with neighbors
        # Example: if this cell has north wall (bit 0),
        # the cell above should have south wall (bit 2)
        if not all([
            (r < 1 or v & 1 == (g[r-1][c] >> 2) & 1),  # North matches neighbor's south
            (c >= len(g[0])-1 or (v >> 1) & 1 == (g[r][c+1] >> 3) & 1),  # East matches neighbor's west
            (r >= len(g)-1 or (v >> 2) & 1 == g[r+1][c] & 1),  # South matches neighbor's north
            (c < 1 or (v >> 3) & 1 == (g[r][c-1] >> 1) & 1)  # West matches neighbor's east
        ]):
            print(f'Wrong encoding for ({c},{r})')



# After the loop, add this before returning:

# 1. Check all required keys exist
missing = require_keys - config.keys()  # Set difference
if missing:
    raise ValueError(f"Missing required keys: {missing}")

# 2. Convert types
try:
    config['WIDTH'] = int(config['WIDTH'])
    config['HEIGHT'] = int(config['HEIGHT'])
    
    # Parse "0,0" into tuple (0, 0)
    entry_parts = config['ENTRY'].split(',')
    config['ENTRY'] = (int(entry_parts[0]), int(entry_parts[1]))
    
    exit_parts = config['EXIT'].split(',')
    config['EXIT'] = (int(exit_parts[0]), int(exit_parts[1]))
    
    # Convert "True"/"False" string to boolean
    config['PERFECT'] = config['PERFECT'].lower() == 'true'
    
except (ValueError, IndexError) as e:
    raise ValueError(f"Invalid value format in config: {e}")

return config