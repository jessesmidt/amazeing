Heuristic Search Explanation (A* Algorithm for Maze Generation)
I'll explain A (A-star)* which is perfect for maze generation, with ASCII visuals!
What is a Heuristic?
Heuristic = An educated guess about how far you are from the goal.
Think of it like this:

You're in a maze at point A
You want to reach point B
Instead of exploring randomly, you explore cells that seem closer to B first


A* Algorithm Basics
Cost Function: f(n) = g(n) + h(n)

g(n) = actual distance from start to current cell
h(n) = estimated distance from current cell to goal (HEURISTIC)
f(n) = total estimated cost
Common heuristic: Manhattan Distance
h = |current_x - goal_x| + |current_y - goal_y|

ASCII Visual Example
Let's find a path from S to G:
Initial maze (5x5):
# # # # #
# S . . #
# . # . #
# . . . G
# # # # #

S = Start (0,0)
G = Goal (3,3)
. = walkable
# = wall
Step-by-step A* execution:
Step 1: Start at S
Current: S(0,0)
Open list: [(0,1), (1,0)]  <- neighbors of S
Closed: [S]

Calculate f(n) for each neighbor:
(0,1): g=1, h=|0-3|+|1-3|=5, f=6
(1,0): g=1, h=|1-3|+|0-3|=5, f=6
Step 2: Pick lowest f(n) - let's say (0,1)
# # # # #
# S * . #   <- * = current position (0,1)
# . # . #
# . . . G
# # # # #

Current: (0,1)
Open list: [(1,0), (0,2)]
Closed: [S, (0,1)]

(0,2): g=2, h=|0-3|+|2-3|=4, f=6
(1,0): f=6 (already calculated)
Step 3: Continue - pick (0,2) or (1,0)
# # # # #
# S * . #
# * # . #   <- now at (0,2)
# . . . G
# # # # #

Current: (0,2)
Open: [(1,0), (0,3)]
Closed: [S, (0,1), (0,2)]

(0,3): g=3, h=|0-3|+|3-3|=3, f=6
Eventually finds path:
# # # # #
# S→→→ #
# ↓ # ↓ #
# ↓→→→G #
# # # # #

Path found! Cost = 7 steps

